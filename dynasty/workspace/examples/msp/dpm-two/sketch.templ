dtmc

// timing:
// tick-0:
//     queue state is observed and state change is planned (pm)
//     request are generated (if service requester is active)
// tick-1:
//     requests are served
//     state change is executed
//     service requester changes its state
//     battery depletes

// initial queue size
const int q_init = 0;

// dummy constants
const int CMAX;
const double THRESHOLD;

// ----- synthesized parameters ------------------------------------------------

// queue size
const int QMAX;
// observation level thresholds
const int T1; const int T2; const int T3;
// actions taken at observation levels
const int A1; const int A2; const int A3; const int A4;
const int Q1; const int Q2; const int Q3; const int Q4;

const int QMAX2;

// ----- modules ---------------------------------------------------------------


// clock

module CLOCK
    c : [0..1] init 0;
    [tick0] c=0 -> (c'=1);
    [tick1] c=1 -> (c'=0);
endmodule


// power manager

module PM
    pm  :  [0..2] init 0; // 0 - sleep, 1 - idle, 2 - active
    pma : [0..1] init 0; // 0 - high, 1 - low
    
    [tick0] q*10 <= T1*QMAX -> (pm'=A1) & (pma'=Q1);
    [tick0] q*10 > T1*QMAX & q*10 <= T2*QMAX -> (pm'=A2) & (pma'=Q2);
    [tick0] q*10 > T2*QMAX & q*10 <= T3*QMAX -> (pm'=A3) & (pma'=Q3);
    [tick0] q*10 > T3*QMAX -> (pm'=A4) & (pma'=Q4);
endmodule

// service provider

module SP
    sp : [0..4] init 0;
    // 0 - sleep, 1 - idle, 2 - active
    // 3 - sleep to idle
    // 4 - idle to active

    // immediate transitions - change to lower-energy (or same) state
    [tick1] sp <= 2 & pm <= sp -> (sp'=pm);

    // transitions through waiting states - change to higher-energy state (sleep to idle or idle to active)
    [tick1] sp <= 2 & pm > sp -> (sp'=sp+3);

    // waiting states
    [tick1] sp = 3 -> 0.5 : (sp'=sp-2) + 0.5 : true;
    [tick1] sp = 4 -> 0.8 : (sp'=sp-2) + 0.2 : true;

endmodule

module SPQ
    spa : [0..1] init 0;
    [tick1] true -> (spa'=pma);
endmodule


// service requester

module SR
    sr : [0..1] init 0; // 0 - idle, 1 - active
    [tick1] sr=0 -> 0.4: true + 0.6: (sr' = 1);
    [tick1] sr=1 -> 0.4: true + 0.6: (sr' = 0);
endmodule

module SR2
    sr2 : [0..1] init 0; // 0 - idle, 1 - active
    [tick1] sr2=0 -> 0.4: true + 0.6: (sr2' = 1);
    [tick1] sr2=1 -> 0.4: true + 0.6: (sr2' = 0);
endmodule

// service request queues

module SRQ
    q : [0..10000] init q_init;
    lost : [0..1] init 0; // request lost flag
    
    // [tick0] sr=1 -> (q'=min(q+1,QMAX)); // request
    [tick0] sr=1 & q < QMAX -> (q'=q+1); // request
    [tick0] sr=1 & q = QMAX -> (lost'=1); // request lost
    [tick0] sr!=1 -> true;

    [tick1] sp=2 & spa=1 -> (lost'=0) & (q'=max(q-1,0)); // serve
    [tick1] sp!=2 | spa=0 -> (lost'=0);
endmodule

module SRQ2
    q2 : [0..10000] init q_init;
    lost2 : [0..1] init 0; // request lost flag

    // [tick0] sr=1 -> (q'=min(q+1,QMAX)); // request
    [tick0] sr2=1 & q2 < QMAX -> (q2'=q2+1); // request
    [tick0] sr2=1 & q2 = QMAX -> (lost2'=1); // request lost
    [tick0] sr2!=1 -> true;

    [tick1] sp=2 & spa=0 -> (lost2'=0) & (q2'=max(q2-1,0)); // serve
    [tick1] sp!=2 | spa=1 -> (lost2'=0);
endmodule


// battery

module BAT
    bat : [0..1] init 1; // 0 empty, 1 - operational
    [tick1] bat=0 -> true;
    [tick1] bat=1 -> 0.01 : (bat'=0) + 0.99 : true;
endmodule

// ----- rewards ----------------------------------------------------------------

label "finished" = (bat = 0);

rewards "time"
    [tick0] true : 1;
endrewards

rewards "queuesize"
    [tick0] true: q;
endrewards

rewards "requests"
    [tick0] sr=1 : 1;
endrewards

rewards "served"
    [tick1] q > 0 & sp=2 : 1;
endrewards

// rewards "lost"
//    [tick0] q=QMAX & sr=1 : 1;
// endrewards

rewards "lost"
    [tick1] lost=1 : 1;
endrewards

rewards "lost2"
    [tick1] lost2=1 : 1;
endrewards

rewards "power"
    [tick1] sp=2 : 100.0 + 10*q; // active
    [tick1] sp=3 : 5.0; // idle to active
    [tick1] sp=4 : 2.0; // sleep to idle
endrewards

rewards "power2"
    [tick1] sp=2 & spa=1 : 100.0 + 10*q; // active
    [tick1] sp=2 & spa=0 : 100.0 + 10*q2; // active
    [tick1] sp=3 : 5.0; // idle to active
    [tick1] sp=4 : 2.0; // sleep to idle
endrewards
