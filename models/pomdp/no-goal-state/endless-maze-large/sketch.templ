pomdp

// 2 | 5 1 2 1 2 1 6
// 1 | 3   3   3   3
// 0 | 4   G   4   4
// y _______________
//   x 0 1 2 3 4 5 6


// can go in this direction
formula u = y<2;
formula r = y=2 & x<6;
formula d = y>0 & (x=0 | x=2 | x=4 | x=6);
formula l = y=2 & x>0;

// target cell
formula goal = x=2 & y=0;
//formula bad = (x=0 | x=4) & y=0;

// updates of coordinates (if possible)
formula yu = u ? (y+1) : y;
formula xr = r ? (x+1) : x;
formula yd = d ? (y-1) : y;
formula xl = l ? (x-1) : x;

// corresponding observables
observable "u" = u;
observable "r" = r;
observable "d" = d;
observable "l" = l;
observable "goal" = goal;
//observable "bad" = bad;

const double succ = 0.6;
const double slipside = 0.18;
const double slipback = 0.04;

// modules
module maze
	x : [0..6] init 0;
    y : [0..3] init 0;
	
	// initialisation
        [place] goal ->
              1/14 :    (x'=0)&(y'=0)
            + 1/14 :    (x'=0)&(y'=1)
            + 1/14 :    (x'=0)&(y'=2)
		+ 1/14 :    (x'=1)&(y'=2)
		+ 1/14 :    (x'=2)&(y'=1)
		+ 1/14 :    (x'=2)&(y'=2)
		+ 1/14 :    (x'=3)&(y'=2)
		+ 1/14 :    (x'=4)&(y'=0)
		+ 1/14 :    (x'=4)&(y'=1)
		+ 1/14 :    (x'=4)&(y'=2)

		+ 1/14 :    (x'=5)&(y'=2)
		+ 1/14 :    (x'=6)&(y'=2)
		+ 1/14 :    (x'=6)&(y'=1)
		+ 1/14 :    (x'=6)&(y'=0)
		;

	// moving around the maze (all combinations)
    
    // [up]    !bad -> succ: (y'=yu) + slipside: (x'=xr) + slipside: (x'=xl) + slipback: (y'=yd);
    // [right] !bad -> succ: (x'=xr) + slipside: (y'=yu) + slipside: (y'=yd) + slipback: (x'=xl);
    // [down]  !bad -> succ: (y'=yd) + slipside: (x'=xr) + slipside: (x'=xl) + slipback: (y'=yu);
    // [left]  !bad -> succ: (x'=xl) + slipside: (y'=yu) + slipside: (y'=yd) + slipback: (x'=xr);

    [up]    !goal -> succ: (y'=yu) + (1-succ): true;
	[right] !goal -> succ: (x'=xr) + (1-succ): true;
	[down]  !goal -> succ: (y'=yd) + (1-succ): true;
	[left]  !goal -> succ: (x'=xl) + (1-succ): true;


endmodule

// rewards

label goal= goal;
